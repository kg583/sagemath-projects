from operator import neg

from labelled_digraphs import LabelledDiGraph


class StallingsGraph(LabelledDiGraph):
	"""
	A StallingGraph is a folded labelled digraph representing a subgroup of a free group.
	Alternatively, a StallingsGraph represents a language generated by words over some alphabet.
	
	Initialization can be done with any of the data formats used for a LabelledDiGraph.
	Additionally, the graph may be initialized with a list of generators, which are themselves lists of letters from some alphabet.
	Two implicit alphabets are recognized:
		
		1) Single characters:	the alphabet spans a-z; the inverse of a is A (and vice-versa)
		2) Integers: 			the alphabet spans the positive integers; the inverse of x is -x
		
	If the generators are not over either of these alphabets, the alphabet must be explicitly passed.
	Elements of explicit alphabets must have inverses accessible via .inverse().
	"""
	def __init__(self, data=None, alphabet=None, pos=None, format=None, weighted=None, vertex_labels=True, name=None, convert_empty_dict_labels_to_None=None, immutable=False):
		if format is None and isinstance(data, list) and ((isinstance(data[0], str) or isinstance(data[0], list) and isinstance(data[0][0], str))):
			format = "generators"
			fold = True
			
		super().__init__(data=data if format != "generators" else None, pos=pos, loops=True, format=format if format != "generators" else None,
						 weighted=weighted, vertex_labels=vertex_labels, name=name,
						 multiedges=True, convert_empty_dict_labels_to_None=convert_empty_dict_labels_to_None,
						 immutable=immutable)
						 
		if format == "generators":
			self.add_vertex(0)
			for generator in data:
				self.add_generator(generator, False)
					
		if format == "generators" or isinstance(data, LabelledDiGraph):
			self._fold()
			
	def _add(generator):
		order = self.order()
		if len(generator) == 1:
			self.add_edge(0, 0, generator[0])
		else:
			self.add_edge(0, order, generator[0])
			
			for label in generator[1:-1]:
				self.add_edge(order, (order := order + 1), label)
				
			self.add_edge(order, 0, generator[-1])
			
	def _fold(self):
		folded = set()
		while len(folded) < self.order():
			vertices = iter(self)
			while (vertex := next(vertices)) in folded:
				pass
			
			incoming, outgoing = {}, {}
			for edge in self.incoming_edge_iterator(vertex):
				incoming[edge[2]] = incoming.get(edge[2], []) + [edge[0]]
				
			for edge in self.outgoing_edge_iterator(vertex):
				outgoing[edge[2]] = outgoing.get(edge[2], []) + [edge[1]]
				
			for fold in incoming.values():
				self.merge_vertices(fold)

			for fold in outgoing.values():
				self.merge_vertices(fold)

			folded.add(vertex)
			
	def _inv(self, word):
		if 'a' in self.alphabet:
			func = str.swapcase
		elif 1 in self.alphabet:
			func = operator.neg
		else:
			func = lambda x: x.inverse()
			
		try:
			return [*reversed(map(func, word))]
		except AttributeError:
			raise ValueError(f"Elements of {self.alphabet} lack inverses.")
			
	def add_generator(self, generator):
		"""
		Add a generator to the subgroup being represented by this Stallings graph.
		"""
		self._add(generator)
		self._fold()
		
	def add_generators(self, generators):
		"""
		Add generators to the subgroup being represented by this Stallings graph.
		
		This method is preferable to multiple calls to add_generator as the folding process is initiated only after all generators are added.
		"""
		for generator in generators:
			self._add(generator)
			
		self._fold()
			
	def basis(self, vertex=0):
		tree = set(self.spanning_tree(vertex))
		
		paths = {vertex: []}
		for edge in tree:
			paths[edge[1]] = paths[edge[0]] + [edge[2]]
			
		return [paths[edge[0]] + [edge[2]] + self._inv(paths[edge[1]]) for edge in self.edges() if edge not in tree]
		
	language = basis
		
	def is_finite_index(self):
		return self.is_regular()
		
	product = tensor_product